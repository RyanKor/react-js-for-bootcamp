# 리액트를 다루는 기술

## 학습 기간

- 7일

- 일전에 리액트를 다루는 기술을 읽다가 중간에 그만뒀던 터라, 절반 정도 내용은 이해하고 있다.

---

## 학습 내용

### 앞단 내용 학습 (2020.07.12)

1.1 리액트의 이해

- 리액트는 View만을 신경쓰는 라이브러리다.
- 뷰를 `업데이트한다`라는 표현은 적절하지 않다. 리액트는 `조화과정을 거친다`는 표현이 더 정확하다.

  1.2 리액트의 특징

- Virtual DOM : 동적 UI에 최적화 되어 있지 않은 HTML문서에서 최소한으로 DOM을 조작해서 효율적인 업데이트를 추구하는 방식으로 발전해옴. 여기서 DOM에 접근해서 조작하는 대신 추상화한 자바스크립트 객체를 구성하는 형태가 `Virtual DOM`이다.

  2.2 JSX

- 가독성 측면도 그렇고 활용도 부분에 있어서도 그렇고 JSX를 사용하는 것을 리액트 공식문서에서도 권장하는 형태인 것 같다.

```javascript
//이 코드는 리액트에서 이렇게 변환된다.
function App() {
  return (
    <div>
      Hello <b>React</b>
    </div>
  );
}

//매번 코드를 작성할 때마다 자바스크립트에 있는 createElement 코드를 불러와서 작업할 수는 없다.
function App() {
  return React.createElement(
    "div",
    null,
    "Hello",
    React.createElement("b", null, "react")
  );
}
```

- JSX 문법을 활용한다는 것은 이미 Virtual DOM을 사용하고 있다는 의미이기도 하다.

- 화살표 함수와 `function` 차이를 구분

- this를 사용할 때, 화살표 함수는 `자신이 종속된 인스턴스`를 지칭하고, function에선 `자신이 종속된 객체`를 가리키고 있을 것이다.

```javascript
//app.js
import React from "React";
import MyComponent from "./MyComponent";

const App = () => {
  return <MyComponent>리액트</MyComponent>;
  // 태그 안의 값을 받을 때는 props.children을 사용한다.
};
```

```javascript
//mycomponent.js
import React from "React";

const MyComponent = (props) => {
  return (
    <div>
      안녕하세요, 제 이름은 {props.name}입니다. <br />
      children 값은 {props.children} 입니다.
    </div>
  );
};

MyComponent.defaulutProps = {
  name: "기본 이름",
};

export default MyComponent;
```

- `this.setState()`는 state 안에 새로운 값을 추가할 때 사용한다.
- 상태를 바꿔주는 함수를 `setter function`이라 부른다.

### 라이프 사이클 이해하기(2020.07.17)

- 변명같이 들릴 수 있지만, 회사 일이 많다보니 저녁에 침대에 눕기만하면 잠드는 경우도 있다.

- 회사 일을 하면서 학습하는 게 이렇게 어려운 거구나!

`getDerivedStateFromProps`: 이 메소드는 마운트 과정에서도 호출되며, 업데이트가 시작되기 전에도 호출된다. props의 변화에 따라 state 값도 변화를 주고 싶을 때 사용한다.

`shouldComponentUpdate` : 컴포넌트가 리렌더링을 해야 할지 말아야 할지를 결정하는 메소드입니다. 이 메소드에는 true 혹은 false 값을 반환해야하며, true를 반환하면 다음 라이프 사이클 메서드를 계속 실행하고, false를 반환하면 작업을 중지합니다. 즉, 컴포넌트가 리렌더링되지 않습니다. 만약 특정 함수에서 this.forceUpdate() 함수를 호출한다면 이 과정을 생략하고 바로 render 함수를 호출합니다.

`render` : 컴포넌트를 리렌더링합니다.

`getSnapshopBeforeUpdate` : 컴포넌트 변화를 DOM에 반영하기 바로 직전에 호출하는 메소드입니다.

`componentDidUpdate` : 컴포넌트의 업데이트 작업이 끝난 후 호출하는 메소드입니다.

`componentWillUnmount` : 컴포넌트가 웹 브라우저상에서 사라지기 전에 호출하는 메소드입니다.

`componentDidCatch` : 컴포넌트 렌더링 도중에 에러가 발생했을 경우 애플리케이션이 먹통이 되지 않고 오류 UI를 보여줄 수 있게 해줍니다.

- 위의 메소드들은 클래스에서만 사용한 라이프 사이클 메소드이고, 이를 대신해서 함수에서도 상태관리를 할 수 있게 작업하고자 `Hooks`가 도입되었다.

`useState` : 하나의 useState는 하나의 상태 값만 관리할 수 있다.

`useEffect` : 리액트 컴포넌트가 리렌더링 될 때마다 특정 작업을 수행하도록 설정하는 Hook. `componentDidMount`와 `componentDidUpdate`를 합친 형태로 봐도 무방하다.

`useReducer` : 현재 상태, 그리고 업데이트를 위해 필요한 정보를 담은 액션 값을 전달받아 새로운 상태를 반환하는 함수다. `reducer` 함수와 `useReducer`의 차이가 어떻게 되는가?

`useMemo` : 함수형 컴포넌트 내에서 발생하는 연산을 최적화하는데 기여한다.

`useCallback` : 렌더링 성능을 최적화하는데 사용한다.

`useRef` : 함수형 컴포넌트에서 ref를 쉽게 사용할 수 있도록 해줍니다.

### 컴포넌트 성능 최적화하기(2020.07.17)

- 리액트 컴포넌트에서 상태를 업데이트할 때 불변성을 지키는 것은 매우 중요하다.
- 많은 데이터를 렌더링하는 경우, 최적화를 찾는 과정에서 `구글 개발자 도구`, 그리고 `useReducer`, `React.memo` 등 등을 사용해서 진행이 가능하다.
- 다른 주소에 다른 화면을 보여주는 것이 `라우팅`이다.
- `<Link>` 컴포넌트는 페이지를 새로고침해서 불러오지 않고 애플리케이션은 그대로 유지한 상태에서 HTML5 History API를 사용해 페이지 주소만 변경해준다는 특징을 갖는다. (a태그가 페이지 전환 과정에서 기존 애플리케이션이 들고 있는 상태들을 모두 날려 버리는 것에 비해 차이남)

### 리액트 프로젝트 : 블로그 만들기 (2020.07.18 ~ 2020.07.20)

- 블로그 회원가입, 로그인 기능을 구현하기 위해 상태 관리하는 과정(Redux, SAGA 등)을 초반에 설계부터 구체적으로 다뤘다. 다만, 서버사이드 렌더링을 별도로 추가해서 사용하지는 않았다.

- 리액트를 다루는 기술에서 앞부분(1강 ~ 23강)은 솔직히 초심자도 따라오는 부분이지만 (내용을 읊어보라고 한다면 80%까지 내용을 코드와 함께 설명할 수 있을 것 같다) 뒷부분(24강 ~ 27강-마무리)은 배운 내용을 철저하게 응용해서 코드 작업을 진행하는 과정이라, 100% 중에서 30% 이해한 것 같다. Redux, Saga가 섞여서 사용되는 부분이 꽤 있었고, 무엇보다 컴포넌트 목적에 따라서 코드 스플리팅이 활발하게 진행되었기 때문에 관리하는 파일이 많다. 즉, `리액트를 다루는 기술`은 24 ~ 27강 내용을 중심으로 복습을 진행하면 될 것 같다.

- 제대로된 대규모 서버를 구성해본 경험이 없지만, 프론트 엔드 작업 할당이 백엔드 작업보다 시간 소요가 크다. 현대 웹 개발에서는 프론트엔드에서 웬만한 작업이 다 처리될 수 있기 때문에 서버는 처리된 데이터만 받아오는 기능만 해도 충분하지 않을까에 대한 생각을 해본다.

- 다만, `리액트를 다루는 기술`에서 배포에 대해 일절 다루는 내용이 없다. 이 부분을 추가적으로 찾아서 내용 학습이 필요하다.

### 리액트 학습 더해보기 (2020.07.20)

- `코드 스플리팅` : 코드가 더 많이 추가되서 500KB를 넘어가기 시작하면 코드 스플리팅을 시작하는 것이 좋다. 프로젝트 규모가 커질 것으로 예상되면 초창기부터 도입하는 것을 고려해야한다.

- `서버 호스팅` : 벨로퍼트 강의에서 다루지 않는데, MongoDB 배포와 리액트가 정적 파일이 아닐 때 배포하는 AWS EC2 배포 법에 대해 찾아야한다.

- `서버사이드 렌더링` : 서버사이드 렌더링에 대해 연결하는 과정이 충분히 설명되어 있지 않다. NginX에 대해 설계가 나와 있으나 서버사이드 렌더링에 대해서도 추가적인 학습이 필요하다.

### 리액트 프로젝트의 반복되는 개발 흐름 (2020.07.20)

- 기능 설계 : 어떤 컴포넌트가 필요할지 생각해야한다. (코드 작성하라는 뜻이 아니다. 충분히 고민하고 기능 설계를 해야한다.)

- UI 만들기 : 사용자에게 보이는 UI를 먼저 만든다.

- API 연동 : API 연동이 필요할 경우 필요한 코드를 준비합니다.

- 상태 관리하기 : 리덕스, 컴포넌트 자체 상태 등을 통해 관리하고, 필요하면 컨테이너 컴포넌트를 새로 만든다.

### 학습 리뷰 (2020.07.20)

- `24 ~ 27강` 내용 2번만 더 보자. 여기 내용을 이해하는 게 `리액트를 다루는 기술` 책 내용을 이해하는 과정이라 봐도 무방할 것 같다.

- 대규모 서버 사용해본 경험은 없지만, 프론트엔드에서 상태 관리가 되기 때문에 서버보다 더 어렵다는 느낌이 든다. 코드 스플리팅도 많아서 파일도 많고. `리액트를 다루는 기술` 책에서 `전체 내용의 30%만 이해한 느낌`이다.

- 이래서 사람들이 리액트를 많이 찾는가 싶다. 코드 스플리팅이 유동적이고, 상태 관리 코드를 작성만 잘하면 대규모 프로젝트 진행에도 어려움이 없을 것이다. Django 처음 배웠을 때랑 느낌이 비슷하다.

- 못 넘을 벽은 없다. 생각의 한계를 깨부수자.
